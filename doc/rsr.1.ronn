rsr(1) -- security & compliance for development platforms
=========================================================

## SYNOPSIS

`rsr` [`--exec`] [`-p` <POLICY_PATH>] [`-n` <NAMESPACE>] [`-o` <OUTPUT>] [INPUT]<br>
`rsr` `--test` [`-o` <OUTPUT>]<br>

## DESCRIPTION

Reposaur (`rsr`) executes Rego [policies][] in <POLICY_PATH> against <INPUT> and outputs SARIF
reports to <OUTPUT>. The <INPUT> argument is optional and defaults to standard input.
Only a single <INPUT> file may be specified. If `-o` is not specified, <OUTPUT> defaults
to standard output.

See also rego-language(1) and rego-reference(1).

## OPTIONS

* `-p`, `--policy`=<POLICY_PATH>:
  Execute or test the [policies][] at <POLICY_PATH>. The path can be either a
  file or directory. Directories are loaded recursively. Defaults to current
  working directory.

* `-T`, `--trace`:
  Enables policy execution tracing.

* `-v`, `--verbose`:
  Print debug logs to standard error output.

* `-V`, `--version`:
  Print the version and exit.

* `-h`, `--help`:
  Print usage and exit.

### Execution options

* `-e`, `--exec`:
  Executes policies. Can't be used with `-t`/`--test`.

* `-o`, `--output`=<OUTPUT>:
  Write reports to <OUTPUT> instead of standard output.
  If <OUTPUT> already exists it will be overwritten.

* `-n`, `--namespace`=<NAMESPACE>:
  The name of the policy package (see [POLICIES][]) that will be executed. [Namespaces][]
  are detected automatically for _repositories_, _organizations_, _users_, _issues_ and
  _pull requests_.

### Test options

* `-t`, `--test`:
  Test policies. Can't be used with `-e`/`--exec`.

## POLICIES

Policies are written using the Rego query language.

### Namespaces

Policy modules start with a package definition. The package's name is
what we call a _namespace_.

    package <NAMESPACE>

Namespaces are used to tell Reposaur which policies it should apply to
which data.

The natively supported namespaces are:

* `repository`:
  A GitHub Repository.

* `pull_request`:
  A GitHub Pull Request.

* `issue`:
  A GitHub Issue.

* `user`:
  A GitHub User.

* `organization`:
  A GitHub Organization.

Custom namespaces can be specified with the `-n`/`--namespace` flag.

### Rules

Only rules with specific prefixes are considered when executing policies:

* `violation_`, `fail_`, `error_`:
  Rules that *must* not fail and pose high security issues. Correspond to `error` in SARIF
  reports and have `CRITICAL` severity level.

* `warning_`, `warn_`:
  Rules that *should* not fail and pose medium security issues. Correspond to `warning` in SARIF
  reports and have `MEDIUM` severity level.

* `note_`, `info_`:
  Rules that *can* fail and don't pose a security issue. Correspond to `note` in SARIF
  reports and have `LOW` severity level.

Additionally, there is a special rule to skip rules in certain cases:

    # Skip repositories from the "note_empty_description"
    # rule if they're not in the InnerSource program
    skip[rules] {
        count({t | input.topics[t] == "innersource"}) == 0
        rules := ["empty_description"]
    }

Note that to skip a rule we don't have to specify it's prefix.

### Built-in functions

Rego comes with a lot of handy built-in functions. Reposaur extends with the following:

* `github.request(<PATH>, <DATA>)`:
  Perform an HTTP request to the GitHub REST API. Supports the same syntax as
  Octokit.js.


      resp := github.request("GET /repos/{owner}/{repo}", {
        "owner": "reposaur",
        "repo": "reposaur",
      })

      resp.status == 200 # true
      resp.body.name == "reposaur" # true

* `github.graphql(<QUERY>, <VARIABLES>)`:
  Perform an HTTP request to the GitHub GraphQL API.

      resp := github.graphql(
        `
          query($owner: String!, $name: String!) {
            repository(owner: $owner, name: $name) {
              name
            }
          }
        `,
        {
          "owner": "reposaur",
          "name": "reposaur",
        }
      )

      resp.status == 200 # true
      resp.body.data.repository.name == "reposaur" # true

### Metadata

Rules in policies can have metadata fields to enhance them with relevant information.
This section always starts with a `# METADATA` header.

* `title`:
  A short, single-sentence description of the rule.

* `description:`
  A longer description of the rule, possibly including how-to fix
  any issues and references. Supports Markdown.

* `common.tags`:
  List of tags that can further help identifying the rule subject or
  group rules by common topics.

* `common.security-severity`:
  A number between 0 and 10 that expresses the security severity of the rule.
  Over 9.0 is `CRITICAL`, 7.0 to 8.9 is `HIGH`, 4.0 to 6.9 is `MEDIUM` and
  3.9 or less is `LOW`.

Example:

    # METADATA
    # title: Repository description is empty
    # description: >
    #   The repository's description is empty, making it harder
    #   for organization members and auditors to understand the
    #   scope of the project.
    #
    #   Fix by adding a description to the repository in the homepage.
    #
    #   See also [InnerSource Guidelines](#)
    # common:
    #   tags: [best-practices, innersource]
    #   security-severity: 0
    note_empty_description {
        input.description == ""
    }

### Tests

Test modules must have a `_test.rego` extension and rules must have the `test_`
prefix.

For the policy:

* `innersource.rego`:

      package repository

      note_empty_description {
          input.description == ""
      }

We could write the following test:

* `innersource_test.rego`:

      package repository

      test_empty_description_should_fail {
          note_empty_description with input.description as ""
      }

      test_with_description_should_pass {
          not note_empty_description with input.description as "some description"
      }

Running these tests should result in success:

    $ rsr -t
    0:00AM INF data.repository.test_empty_description_should_fail: PASS (915µs)
    0:00AM INF data.repository.test_with_description_should_pass: PASS (54.125µs)
    0:00AM INF done failed=0 passed=2 timeEllapsed=1.9335 total=2

## EXIT STATUS

When executing policies, `rsr` will exit 0 even if there are [rules][] failing.

When running policy tests, `rsr` will exit 1 if there are tests failing and
exit 0 otherwise.

If an error occurs during policy compilation or execution, will exit 1. Note that
reports might have already been produced and written to <OUTPUT>.

## EXAMPLES

Streaming data from a file:

    $ cat repos.json | rsr

    $ rsr repos.json

Streaming data from GitHub API:

    $ gh api /orgs/reposaur/repos | rsr

    $ curl https://api.github.com/orgs/reposaur/repos | rsr

Outputing to a file instead of standard output:

    $ cat repos.json | rsr -o out

    $ cat repos.json | rsr > out

Piping to other tools:

    $ cat repos.json | rsr | jq -s length

Running policy tests:

    $ rsr --test

Uploading a report to GitHub Code Scanning:

    $ full_name="reposaur/reposaur"

    $ branch="main"

    $ commit_sha=$(gh api "/repos/$full_name/branches/$branch" -q '.commit.sha')

    $ report=$(gh api "/repos/$full_name" | rsr | gzip | base64)

    $ gh api "/repos/$full_name/code-scanning/sarifs" \
        -f sarif="$report" \
        -f commit_sha="$commit_sha" \
        -f ref="$branch"

## SEE ALSO

[repository][src], [playground][playground], opa(1), rego-language(1), rego-reference(1)

## BUGS

If you find any issue using Reposaur, please fill a [bug report][bug-report]. We appreciate it!

## AUTHORS

Joao Cerqueira <oss@cerqueira.io>
